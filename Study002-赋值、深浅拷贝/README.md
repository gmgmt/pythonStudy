# Study002

# Python全栈学习Day02 -- 0701
@[TOC](目录)
## 基本概念和知识点
		Python的对象有三个属性：
		1、id: 
			代表对象唯一的标识符，是独一无二的，CPython中代表存放对象的内存地址
		2、type：
			 代表着对象的类型
			 和isinstance区别：type不考虑继承，isinstance考虑继承
		3、value：
			代表我们赋给对象的值
		4、==：
			判断引用变量的值是否相等。只判断值和数据类型
		5、is：
			判断两个变量引用对象是否为同一个，就是所引用的对象的内存地址是否一致
## 赋值
### 变量的存储方式
	复习下第一天的学习内容并总结：
	变量的储存方式有两个：
	- 引用赋值：
		变量中存储的只是值的引用，比如我们将整数1赋值给变量a，a中存储的是其值的引用（即地址），值1有另外的存储位置，这样做的好处是我们在给变量赋值时不需要提前声明，因为变量存储的是值对象的引用，那所有变量在内存中的大小都是一样的，就是一个地址。也被称为对象语义和指针语义。
	- 按值赋值：
		把变量的值直接存放在变量的存储区里，这样一来，每个变量所需存储区的大小是不一样的，存放数字和存放字符串所需空间大小就不同，这就需要在给变量赋值时根据值的类型声明变量的类型，静态语言比如c，c++都有值语义。
## Python对象的存储方式
### Python对象分类
#### 可变对象
	list dict set
	可变对象创建后可改变但地址不会改变，即变量指向的还是原来的变量
#### 不可变对象
	tuple string int float bool
	不可变对象创建之后便不能改变，如果改变则会指向一个新的对象。
#### 实例
	# 字符串实例
	a = "hello"
	print(id(a))  # 输出 140022851974560
	
	a[0]="a"  # 抛出异常：TypeError: 'str' object does not support item assignment
	a = a + " world"
	print(id(a))  # 输出 140022850763824
	
	# 列表实例
	a = [1,2,3]
	print(id(a))  # 输出 140022851303976
	
	a[0]=5
	print(a)      # 输出 [5, 2, 3]
	print(id(a))  # 输出 140022851303976
	
	a.append(5)print(a)      # 输出 [5, 2, 3, 5]
	print(id(a))  # 输出 140022851303976
	b = a
	print(id(b))  # 输出 140022851303976
	
	b[0] = 6
	print(b)      # 输出 [6, 2, 3, 5]
	print(a)      # 输出 [6, 2, 3, 5]
	
	c = b[:]
	print(id(c))  # 输出 140022851006760
	print(id(b))  # 输出 140022851303976
	
	c.append(7)
	print(c)      # 输出 [6, 2, 3, 5, 7]
	print(b)      # 输出 [6, 2, 3, 5]
大家可以自行下去尝试代码实践其余数据类型是否为可变或者不可变
## 拷贝方法
### 浅拷贝方法
	直将第一层的元素进行拷贝，重新生成地址引用，原对象和拷贝对象是两个不同的对象，但是第二层的元素的地址引用还是相同的，因此修改第一层元素只有被修改的变量会变，但修改第二层元素，两个变量的值都会变。
#### 切片方法
	li = ['li', [100, 200, 300]]
	li_1 = li[:]       # 切片方法
	li_2 = list(li)    # 工厂方法
#### 工厂方法
	li_2 = list(li)    # 工厂方法
#### 浅拷贝
	import copy
	li_3 = copy.copy(li)    # 浅拷贝
### 深拷贝方法
	既然浅拷贝是只拷贝一层，那么深拷贝当然就是完全的拷贝，不管对象里面嵌套了基层数据结构，直接拷贝到元素为不可变对象时才结束，这样拷贝出来的新对象就和原对象完全没有关系，无论如何修改，都不会对另一个起到影响。
	li_4 = copy.deepcopy(li)  # 深拷贝
### 实例
```
import copy
li = ['li', [100, 200, 300]]
li_1 = li[:]       # 切片方法
li_2 = list(li)    # 工厂方法
li_3 = copy.copy(li)    # 浅拷贝
li_4 = copy.deepcopy(li)  # 深拷贝
print('li', li, 'id:', id(li))
print('li1', li_1, 'id:', id(li_1))
print('li2', li_2, 'id:', id(li_2))
print('li3', li_3, 'id:', id(li_3))
print('li4', li_4, 'id:', id(li_4))

# 运行结果
# li ['li', [100, 200, 300]] id: 47813336
# li1 ['li', [100, 200, 300]] id: 47814096
# li2 ['li', [100, 200, 300]] id: 47513768
# li3 ['li', [100, 200, 300]] id: 47508656
# li4 ['li', [100, 200, 300]] id: 56333696
# 可以看到id都不一样，说明他们指向的都不是同一个列表对象
# 将除深拷贝以外任意一个方法的‘100’，重新赋值为400, 再次运行结果为
li_2[1][0] = 400
print('li', li, 'id:', id(li))
print('li1', li_1, 'id:', id(li_1))
print('li2', li_2, 'id:', id(li_2))
print('li3', li_3, 'id:', id(li_3))
print('li4', li_4, 'id:', id(li_4))
# li ['li', [400, 200, 300]] id: 56332976
# li1 ['li', [400, 200, 300]] id: 56333736
# li2 ['li', [400, 200, 300]] id: 56033528
# li3 ['li', [400, 200, 300]] id: 56028416
# li4 ['li', [100, 200, 300]] id: 56333696
# 可以看到：只改变了一个列表而除deepcopy之外其他的列表对象都变成的‘400’
print('li', li, 'id:', id(li))
print('li1', li_1, 'id:', id(li_1))
print('li2', li_2, 'id:', id(li_2))
print('li3', li_3, 'id:', id(li_3))
print('li4', li_4, 'id:', id(li_4))
```
因为除deepcopy之外其它的拷贝方法都只是拷贝了列表中对象的引用，再开辟一块新的内存来储存，如果其中一个数据变了， 其他的也会跟着改变。

#### 拓展：小数据池
**代码块**
```
Python 程序 是由代码块构造的。块是一个python程序的文本，它是作为一个执行单元的。
代码块：一个模块，一个函数，一个类，一个文件等都是一个代码块。
而作为交互方式输入的每个命令都是一个代码块。
什么叫交互方式呢？就是咱们在cmd中进入python解释器里同，每一行代码就是一个代码块;对于一个文件中的两个函数，也分别是两个不同的代码块。
```
**代码块的缓存机制**
```
Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用。换句话说：执行同一个代码块时，遇到初始化对象的命令时，他会将初始化的这个变量与值存储在一个字典中，在遇到新的变量时，会先在字典中查询记录，如果有同样的记录那么它会重复使用这个字典中的之前的这个值。满足缓存机制则他们在内存中只存在一个，即：id相同。
```
**代码块的缓存机制的适用范围**
```
int（float），str，bool。
int(float):任何数字在同一代码块下都会复用。
bool:True和False在字典中会以1，0方式存在，并且复用。
优点：能够提高一些字符串，整数处理人物在时间和空间上的性能；
需要值相同的字符串，整数的时候，直接从‘字典’中取出复用，避免频繁的创建和销毁，提升效率，节约内存。
```
**小数据池**
```
小数据池，也称为小整数缓存机制，或者称为驻留机制等
大前提：小数据池也是只针对 int(float)，str，bool。
小数据池是针对不同代码块之间的缓存机制！！！

- int： 对于整数来说，当整数范围在 -5 ~ 256 这个闭区间时，会放进小数据池，此时多个变量同时指向同一个（在这个范围内的）数字，他们在内存中指向的都是一个内存地址。
- str：
	1、字符串的长度为0或1时，默认都采用驻留机制（小数据池）
	2、字符串的长度>1,且只含有大小写字母，数字，下划线时，才会默认驻留
	3、用乘法得到的字符串，分两种情况：
		乘数为1时: 
			仅含大小写字母，数字，下划线，默认驻留。
			含其他字符，长度>1, 默认驻留。
		乘数 >= 2 时：
			仅含大小写字母、数字、下划线，总长度<=20，默认驻留。
	4、指定驻留
		>>> from sys import intern
		>>> a = intern('hello!@' * 20 )
		>>> b = intern('hello!@' * 20 )
		>>> print(a is b)
		True
		>>>
- bool：bool值 就是True,False,无论你创建多少个变量指向True,False,那么他在内存中只存在一个。
```
	在pycharm中运行python程序时，pycharm出于对性能的考虑（非驻留比较效率o(n)，驻留时比较效率o(1)），会扩大小整数池的范围，其他的字符串等不可变类型也都包含在内一便采用相同的方式处理了，我们只需要记住这是一种优化机制，至于范围到底多大，无需细究。
```
实例
>>> a=2
>>> b=2
>>> a is b
True
```
**总结：
1、只有可变对象才有深浅拷贝之分，不可变对象都是一样的，均会改变
2、可变对象的浅拷贝第一层不会跟随改变、其余层会跟随变化。**